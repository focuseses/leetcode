Common Techniques :)
1. Two Pointer 
- Array has to be sorted
- Once the array is sorted the two pointers can be taken which mark the beginning and end of the array respectively
- If the sum is greater than the sum of those two elements, shift the right pointer to decrease the value of the required sum 
- If the sum is lesser than the required value, shift the left pointer to increase the value of the required sum 

2. Prefix sum
- Additional array to collect the sum of the elements till its position 

3. Hashmap vs hashset
Hashmap: duplicates values are allowed but no duplicate key is allowed 
- Hashmap (key = number, value = target - number) to check if the pairs are present
For python:
dict1 = dict(X=1, Y=2, Z=3)
or {'X': 1, 'Y': 2, 'Z': 3}
or 
dict = {} 
dict[X] = 1

4. Interval tree
Supports 
- Add an interval 
- Remove an interval 
- Given an interval x, find if x overlaps with any of the existing intervals.
Search:
1) If x overlaps with root's interval, return the root's interval.
2) If left child of root is not empty and the max in left child 
is greater than x's low value, recur for left child
3) Else recur for right child.

(Intervals//Duplicates questions) Sort first!

5. Useful python functions
lst = ["a", "b", "c"] 
"".join(lst) gives "abc"

txt = "hello lol"
txt.split(["hello", "lol"])

print a dic into a list
print(dic[elem] for elem in dic)

6. Detecting cycles 
A. Hashing approach 
- Hash each node address
- Traverse through the list while checking if it is in the hash table.
O(n) since n x O(1) checks
Space: O(n)

B.  Space: O(1) -> using 2 pointers which travel different speed.

7. Sliding Window 
(The condition to use the sliding window technique is that the problem 
asks to find the maximum (or minimum) value for a 
function that calculates the answer repeatedly for a 
set of ranges from the array.)
Have two pointers
If it is valid, move right pointer to right. 
If not valid, move left pointer to right. 
- Finding maximum sum of k consecutive elements in an array 
- Finding subarray of size k with given sum 
- Finding all anagrams in a string 
- Minimum Window Substring

8. LinkedList
Let head be the entire linked list. 
To get the head value, head.val
Get tail value, head.next

9. Dynamic Programming Steps
State: dp(i, j) = maximum sum of happiness on day i if i do activity j on that day
State space: i=1..N and j={A=0, B=1, C=2 }
Transition: dp(i, j) = max(dp(i-1, (j - 1)%3) + cost(i, j), dp(i-1, (j + 1)%3) + cost(i, j))
Base Case: dp(1, 0) = a_i, dp(1, 1) = b_i, dp(1, 2) = c_i
Time complexity: O(state space) * O(transition) = O(n) * O(1) = O(n)
